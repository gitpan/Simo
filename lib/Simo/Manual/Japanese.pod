=encoding utf-8

=head1 NAME

Simo::Manual::Japanese - Simo Manual writen by Japanese

日本語で書かれたSimoのマニュアル　書きかけ

=cut

=head1 Simoとは

　Simoはオブジェクト指向を簡単にするためにかなりの注意が払われました。
　オブジェクト指向というのはPerlが非常に苦手とする分野です。リファレンスとblessという
方法を使って、他のオブジェクト指向と遜色のないオブジェクト指向を実現できますが、
記述が非常に煩雑です。

　同じようなアクセッサの定義をクラスを作成するたび、アクセッサを生成するたびに行う必要がありました。
また毎回同じようなnewメソッドの定義を行う必要がありました。これは非常に退屈な作業でした。
　また、堅固なオブジェクトを作成するためには、newメソッドが受け付ける属性を制限したり、
渡される値を制限したりする必要があります。
　Simoはこれらの退屈な作業を変わりに引き受けます。そして、それに加えて、
非常に柔軟なオブジェクトシステムを提供します。

　SimoはMooseから非常に多くのものを学びました。newメソッドの自動生成、use を使った継承、
メタプログラミングを使用したアクセッサの生成、値の制約、strictプラグマとwarningsプラグマのインポートなどです。

　Mooseが「まったく新しいパラダイム」「多機能で完全なオブジェクトシステム」を目指しているのに対して、
Simoは、「簡潔さ」と「既存のPerlのオブジェクトシステムとの親和性」を目指しています。
今までに覚えたPerlのオブジェクト指向の記述にできるだけ調和するように設計されています。
またどこでエラーが起こったのかがはっきりわかるようなエラーメッセージを表示する設計になっています。

=cut

=head1 簡潔なアクセッサの記述

Simoは、現存するオブジェクトシステムの中でも際立って簡潔にクラスを作成することができます。
これほど少ないコード量でクラスを作れるのはおそらくSimoだけです。
title, author, price という属性を持った、Bookクラスを作成するには以下のようにします。

    package Book;
    use Simo;
    
    sub title{ ac }
    sub author{ ac }
    sub price{ ac }

　Simoは既存のPerlのオブジェクト指向との親和性を目指しているといいました。
　既存のPerlのオブジェクト指向はたとえば以下のように書きます。
　
    package Book;

    sub new {
        my $thing = shift;
        my $class = ref $thing || $thing;
        bless { @_ }, $class;
    }
    
    sub title{
        my $self = shift;
        if( $@ ){
            $self->{ title } = $_[0];
        }
        return $self->{ title };
    }
    
    sub title{
        my $self = shift;
        if( $@ ){
            $self->{ title } = $_[0];
        }
        return $self->{ title };
    }
    
    sub title{
        my $self = shift;
        if( $@ ){
            $self->{ title } = $_[0];
        }
        return $self->{ title };
    }

　非常に煩雑で、やりたいことが何なのかを忘れてしまいそうなコードです。
　Simoではnewを定義する必要がありません。そして、アクセッサの定義を
　ac に置き換えるだけでよいのです。

=cut

=head1
　
　
　
　SimoはPerlのオブジェクト指向を簡単にするためのモジュールです。
簡潔な記述でクラスを作成することができます。

従来の問題点は、アクセッサ定義の面倒さ、同じようなnewメソッドを毎回作成しなくてはならないこと、
アクセッサに設定される値にある程度の制約を持たせたいこと、
オブジェクトを作成するときに必須のキーがある場合それを制御しなければならないこと。

　Simoはオブジェクト指向プログラミングにおいて二つの役割を持ちます。
　ひとつは、基底クラスとしての役割です。Simo自体は、newというコンストラクタ、
　set_attrs, get_attrs, get_attrs_as_hash という属性を便利に設定するためのメソッド、
　run_methods というメソッドを連続的に実行するためのメソッド、
　REQUIRED_ATTRSという、newに必須で渡されなければならない項目を設定するためのメソッドを
備えます。
　Simoは、オブジェクト指向の中での基底クラスであり、属性の操作に役立つメソッドを提供します。

　Simoのもうひとつの役割は、柔軟なアクセッサの生成です。Simoをuse すると、アクセッサ定義のための関数
　ac関数が、エクスポートされます。
　ac関数は、柔軟にアクセッサを生成します。デフォルト値の設定、値の制約、フィルタ、トリガー、読み取り専用設定、
　引数のハッシュに強制、という機能を持っています。

SimoはMooseが抱える困難に対するひとつのシンプルな回答です。Mooseの

=head1 読み取り専用(リードオンリー)なアクセッサの生成

　read_only オプションに真値を設定すると、そのアクセッサは読み取り専用になります。
読み取り専用のアクセッサに値を設定しようとすると例外が発生します。
　読み取り専用のアクセッサは次のように、デフォルト値の設定とともに使用されるのが一般的です。
　以下のはLWP::UserAgentをデフォルト値として設定して、利用できるようにする例です。
　read_onlyオプションが設定されているため、この値をアクセッサを通じて変更することはできません。

    sub lu{ ac default => LWP::UserAgent->new, read_only => 1 }

=cut

=head1 アクセッサに渡される配列をハッシュとして解釈する
　
　通常はアクセッサにリストが渡されたとき、そのリストは配列のリファレンスに変換されます。
けれども、あるアクセッサの値にハッシュ値を使用したい場合、アクセッサにリストが渡されたとき
ハッシュに変換してほしいと思うことでしょう。
　この振る舞いを変更して、渡された値をハッシュのリファレンスに変換するようにするには、hash_forceオプションを
使用します。
　hash_forceオプションが指定されたアクセッサにリストを渡すと、そのリストはハッシュのリファレンスへと
変換されて格納されます。
    
    # アクセッサの定義
    sub country_id{ ac hash_force => 1 }
    
    # アクセッサで値を設定  
    $obj->country_id( japan => 1, USA => 2 );
                     # { japan => 1, USA => 2 } へと変換されて格納される

=cut

.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Simo 3"
.TH Simo 3 "2008-12-16" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Simo \- Very simple framework for Object Oriented Perl.
.SH "VERSION"
.IX Header "VERSION"
Version 0.01
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Sh "Creating class and accessors"
.IX Subsection "Creating class and accessors"
Simo is framework that simplify Object Oriented Perl.
If you use Simo, You can write class and accessors very very simple way.
.PP
If you want to class and accessors, you do this way.
.PP
.Vb 2
\&    package Book;
\&    use Simo;
\&    
\&    # accessors
\&    sub title{ ac }
\&    sub author{ ac }
\&    sub description{ ac }
.Ve
.PP
This code create Book class and three accessors, title,author and description.
You no longer write accessors implementations repeat.
.PP
and
.PP
new method is automatically created.
You no longer write new method.
.Sh "Using class and accessors"
.IX Subsection "Using class and accessors"
You use this class this way.
.PP
.Vb 1
\&    use Book;
\&    
\&    # constructor
\&    my $book = Book\->new(
\&        title => \*(AqHappy book\*(Aq,
\&        author => \*(AqKen\*(Aq,
\&        description => \*(Aqthis give you happy\*(Aq,
\&    );
\&    
\&    # get value
\&    $book\->title;
\&    
\&    # set value
\&    $book\->author( \*(AqTaro\*(Aq );
.Ve
.PP
You pass args to new method. args is key-value pair.
If you pass key which is not defined as accessor, the script will die.
.PP
If you get value, you write \f(CW$book\fR\->title;
.PP
If you set value, you write \f(CW$book\fR\->title( 'Taro' );
.Sh "Define default value"
.IX Subsection "Define default value"
You can define default value for accessor.You do this way.
.PP
.Vb 2
\&    package Book;
\&    use Simo;
\&
\&    sub title{ ac( \*(AqPapa\*(Aq ) }
.Ve
.PP
It is also very simple to define default value. 
You can pass default value as ac function first arg.
.Sh "Value check by regular expression"
.IX Subsection "Value check by regular expression"
You can check value passed to accessor using regular expression.
.PP
.Vb 2
\&    package Book;
\&    use Simo;
\&
\&    sub price{ ac( 2000, qr/^\ed+$/ ) }
\&    
\&    package main;
\&    use Book;
\&    my $book = Book\->new;
\&    $book\->price( \*(Aqaaaa\*(Aq ) # this code die.
.Ve
.PP
You can pass regular expression reference( qr// ) as ac function second arg.
.PP
Note: default value is not checked. in this sample, 2000 is not checked.
.Sh "Hook function for validation or filter."
.IX Subsection "Hook function for validation or filter."
You can define hook function for accessor.
.PP
.Vb 2
\&    package Book;
\&    use Simo;
\&
\&    sub date{ ac( \*(Aq20080101\*(Aq, \e&date_filter ) }
\&    
\&    #filter ( for example, \*(Aq2008\-10\-10\*(Aq \-> \*(Aq20081010\*(Aq )
\&    sub date_filter{
\&        my ( $val ) = @_;
\&        $val =~ s/\-//g;
\&        return $val
\&    }
\&    
\&    package main;
\&    use Book;
\&    my $book = Book\->new;
\&    $book\->date( \*(Aq2008\-10\-10\*(Aq );
\&    print $book\->date; # 20081010
.Ve
.PP
You can pass code reference as ac function second arg.
The code reference is executed before set value by accessor.
.PP
In this example, If you set '2008/10/10', It change '20081010'.
.PP
Your hook subroutine can receive two args.
.PP
1. passed value by setter.
.PP
2. self ( this object )
.PP
If you need, you can access self.
.PP
.Vb 2
\&    sub date_filter{
\&        my ( $val, $self ) = @_;
\&        
\&        $val =~ s/\-//g;
\&        $self\->title; # You can call other accessors or methods.
\&        ...
\&    }
.Ve
.SH "Automatically type convert"
.IX Header "Automatically type convert"
If you pass array to accessor, its array convert to array ref.
    \f(CW$book\fR\->title( 'a', 'b' );
    \f(CW$book\fR\->title; # get [ 'a', 'b' ], not ( 'a', 'b' )
.SH "Class option"
.IX Header "Class option"
Simo has class options. You set options this way.
.PP
.Vb 1
\&    use Simo qw( option1 option2 ... );
.Ve
.Sh "arg_top option"
.IX Subsection "arg_top option"
If you set arg_top option, first arg of new passed specified accessor. 
if args count is odd number
.PP
.Vb 1
\&    use Simo qw( arg_top:title );
\&
\&    my $book = Book\->new( \*(AqHappy book\*(Aq, author => \*(AqKen\*(Aq );
\&                          # first arg passed title accessor
\&                          # if args count is odd number
.Ve
.Sh "Array wrapper"
.IX Subsection "Array wrapper"
You can wrap array using your array wrapper class
.PP
.Vb 3
\&    # use your list wrapper class
\&    package Book;
\&    use Simo qw( ary_struct:Book::Array );
\&
\&    sub authors{ ac };
\&    
\&    
\&    package Book::Array; 
\&    sub new{
\&        bless $_[1], ref( $_[0] ) || $_[0]; 
\&    }
\&    
\&    sub length{
\&        my $self = shift;
\&        return scalar @{ $self }
\&    }
\&    
\&    or
\&    
\&    # use list wrapper class in CPAN
\&    package Book;
\&    use List::Rubyish; 
\&    
\&    use Simo qw( ary_struct:List::Rubyish );
\&    sub authors{ ac };
.Ve
.PP
You can use this class
.PP
.Vb 3
\&    use Book;
\&    my $book = Book\->new;
\&    $book\->authors( \*(AqKen\*(Aq, \*(AqTom\*(Aq ); #set authors
\&    
\&    print $book\->authors\->length; # get and call length method. result is 2.
.Ve
.Sh "Hash wrapper"
.IX Subsection "Hash wrapper"
You can also use hash_struct otpion
.PP
.Vb 2
\&    package Book;
\&    use Simo qw( hash_struct:Book::Hash );
.Ve
.Sh "Setter return value type"
.IX Subsection "Setter return value type"
You can set setret option this way.
.PP
.Vb 2
\&    package Book;
\&    use Simo qw( setret:before );
.Ve
.PP
If you use setret option You can select setter return value type
.PP
1.current : return value is current value
.PP
.Vb 2
\&    $book\->title( 1 );
\&    my $ret = $book\->title( 2 ); # $ret is 2
.Ve
.PP
2.before : return value is before value
.PP
.Vb 2
\&    $book\->title( 1 );
\&    my $ret = $book\->title( 2 ); # $ret is 1
.Ve
.PP
3.chain : return value is self
.PP
.Vb 2
\&    $book\->title( 1 );
\&    my $ret = $book\->title( 2 ); # $ret is $book
\&
\&    # so you can use method chain.
\&    $book\->title( \*(Aqa\*(Aq )\->author( \*(Aqb\*(Aq );
.Ve
.SH "Accessor option"
.IX Header "Accessor option"
You can use accessor option.
.PP
You can set many option more than default value and hook function.
.PP
If you must pass 'opt' as first arg and  pass hash ref as second arg,
.PP
do this way.
.PP
.Vb 2
\&    package Book;
\&    use Simo;
\&
\&    sub title{ ac( opt => { default => 2, hook => sub{} } ) };
.Ve
.PP
The following is example, all accessor option set.
.PP
.Vb 10
\&    sub title{
\&        ac( opt => {
\&            default => 2,
\&            hook => sub{ },
\&            setret => \*(Aqbefore\*(Aq,
\&            ary_struct => \*(AqBook::Array\*(Aq,
\&            hash_struct => \*(AqBook::Hash\*(Aq,
\&            hash_force => 1,
\&        });
\&    }
.Ve
.PP
Accessors option is same as class options except hook or hash_force;
.PP
If you use accessor option, you can adapt opiton only individual accessor.
.PP
I still do not said to you about hash_force option.
.Sh "force setter to receive list as hash"
.IX Subsection "force setter to receive list as hash"
You can force setter to receive list as hash
.PP
.Vb 3
\&    package Book;
\&    use Simo;
\&    sub country_id_list{ ac( opt => { hash_force => 1 }) }
\&    
\&    package main;
\&    my $book = Book\->new;
\&    $book\->country_id_list( japan => \*(Aqjp\*(Aq, USA => \*(Aqus\*(Aq );
\&         # { japan => \*(Aqjp\*(Aq, USA => \*(Aqus\*(Aq } ,not [ \*(Aqjapan\*(Aq, \*(Aqjp\*(Aq, \*(AqUSA\*(Aq, \*(Aqus\*(Aq]
.Ve
.SH "EXPORT"
.IX Header "EXPORT"
This class exports ac function. you can use ac function to implement accessor.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.Sh "ac"
.IX Subsection "ac"
ac is accessor interface. if you create accessor, you do this.
    package Book;
    use Simo;
.PP
.Vb 2
\&    sub title{ ac }
\&    ...
.Ve
.PP
You can use this method as getter and setter.
.PP
Getter is
    \f(CW$book\fR\->title;
.PP
Setter is 
    \f(CW$book\fR\->title( 'Bird Adventure' );
.Sh "new"
.IX Subsection "new"
new is created automatically. 
by default, new receive hash args.
.PP
.Vb 1
\&    my $book = Book\->new( title => \*(AqPaPa is good\*(Aq, author => \*(AqMaMa\*(Aq );
.Ve
.SH "MORE TECHNIQUES"
.IX Header "MORE TECHNIQUES"
I teach you useful techniques.
.Sh "want to create new function by yourself."
.IX Subsection "want to create new function by yourself."
Please look at '$self\->SUPER::new' in this code.
.PP
What I shoud said to you is that Book extends Simo, 
although there are no 'use base' or '@ISA'.
.PP
.Vb 2
\&    package Book;
\&    use Simo;
\&
\&    sub new{
\&        my ( $self, @args ) = @_;
\&        # ... You write what you want to do
\&        
\&        return $self\->SUPER::new( @args );
\&    }
\&
\&    sub title{ ac }
.Ve
.PP
you can call SUPER::new method.
.PP
If you want to create new function by yourself,
first you write what you do 
and finally call \f(CW$self\fR\->SUPER::new.
.Sh "inheritance"
.IX Subsection "inheritance"
You can inherit super clsss.
.PP
This sample : PBook extends Book.
.PP
.Vb 2
\&    package Book;
\&    use Simo;
\&
\&    sub title{ ac }
\&
\&    package PBook;
\&    use base \*(AqBook\*(Aq;
\&    use Simo;
\&    
\&    sub author{ ac } # PBook has two accessor, title and author
.Ve
.PP
You can do inheritance by using normal way that use 'use base'.
If you define accessors simply in PBook package,
please use Simo again.
.SH "AUTHOR"
.IX Header "AUTHOR"
Yuki Kimoto, \f(CW\*(C`<kimoto.yuki at gmail.com>\*(C'\fR
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to \f(CW\*(C`bug\-simo at rt.cpan.org\*(C'\fR, or through
the web interface at <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Simo>.  I will be notified, and then you'll
automatically be notified of progress on your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Simo
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
\&\s-1RT:\s0 \s-1CPAN\s0's request tracker
.Sp
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Simo>
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
<http://annocpan.org/dist/Simo>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
<http://cpanratings.perl.org/d/Simo>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
<http://search.cpan.org/dist/Simo/>
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2008 Yuki Kimoto, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
